import {Set} from 'immutable';
import {Observable} from 'rxjs';
import {TimeRange, TimeRangeInterval} from '../../dashboard/models';
import {
  BarWidget,
  BillboardWidget,
  CallTimeLineWidget,
  GeoMapWidget,
  LineWidget,
  SankeyWidget,
  SolidGaugeWidget,
  SunburstWidget,
  TabularWidget, TimeInterval,
  TrendDiffWidget, LiquidFillGaugeWidget, KpiThresholds
} from '../../widgets/models';
import {DataSet, PolicyGroup, ProcessStrategy, RealtimeData, StartOptions, Subscription, Topic, ActionPolicy, PolicyInfo} from '../models';
import {ChartDataConverterService} from './converters';
import {ColorPalette, InstanceColor} from '../../common/models/index';
import {WebSocketSubscription} from '../models/web-socket/widget-container';

export interface Series {
  type?: any;
  id?: string;
  name?: any;
  data?: any;
  color?: any;
  nodes?: any;
  stack?: string;
  timestamp?: any;
  dataLabels?: any;
  zoneAxis?: any;
  zones?: any;
  step?: string;
  dashStyle?: string;
  linkedTo?: string;
  item?: string;
}

export interface RealTimeDataProcessor {

  /**
   * Filter data that has key is one of keys
   */
  filterDataByKeys(data: DataSet, keys: string[]): DataSet;

  /**
   * Filter data whose measure exists in measures array
   */
  filterDataByMeasures(data: DataSet, dataType: string, measures: string[], windows: string[]): DataSet;

  /**
   * Filter data whose measure and instance exists in measures array and instances array
   */
  filterDataByInstancesAndMeasures(data: DataSet, dataType: string, instances: any, measures: string[], windows: string[]): DataSet;
  /**
   * Filter instance data by instance format
   */
  filterDataByInstanceFormat(data: DataSet, dataType: string, instanceFormat: RegExp): DataSet;
  /**
   * Filter sankey data when user add new instances
   */
  filterDataByIdentifyInstances(data: DataSet, dataType: string, instances: string[], measures: string[]): DataSet;
  /**
   * Get latest timestamp of the data
   */
  getLatestTimestamp(data: DataSet): number;

  /**
   * Return the timestamp at which point there are data and the measureTimestamp is less than or equal to maxTimestamp
   */
  getLatestTimestampHavingData(data: DataSet, maxTimestamp: number): number;

  /**
   * Get latest timestamp of the data
   */
  getLatestRecord(data: DataSet): RealtimeData;

  getOldestRecord(data: DataSet): RealtimeData;

  /**
   * Get all data which have same measureTimestamp value and equal latest timestamp
   */
  getAllLatestTimestampData(data: DataSet): DataSet;

  /**
   * Get data in specified time range
   */
  getDataInTimeRange(data: DataSet, range: { startTimestamp: number, endTimestamp: number }): DataSet;
  /**
  * Get data for trenddiff with custom timestamps
  */
  getDataTrendDiffRange(data: DataSet, timestamps: number[]): DataSet;

  /**
   * Generate data by apply formula measure expression to data have the same key and timestamp
   * @param {Set<RealtimeDataRecord>} data Set of data to generate from
   * @param {string[]} measureNames A list of measure names which contain formula measureName names,
   * measure which is not formula measureName is ignored
   * @returns {Set<RealtimeDataRecord>} Generated data set wich contain data generated by apply formula
   */
  generateFormulaMeasureData(data: DataSet, dataType: string, measureNames: string[]): DataSet;

  /**
   * Return element measures built from input measures which containing formula measures
   * Formula measures are included in the list.
   * @param {string[]} measures
   */
  getElementMeasures(measures: string[]): string[];

  /**
   * Get data in specified input range (time range + interval value)
   */
  getDataInInputRange(data: DataSet, range: { startTimestamp: number, endTimestamp: number },
                      interval: TimeInterval, historicalTimeStamp: number[]): DataSet;

  /**
   * KPI data
   */

  getKpiData(data: DataSet, hideKpi: KpiThresholds): DataSet;
}

export interface ReportingDataSubscriptionService {
  addNewPackage(packageName: string, topicName: string): Observable<any>;

  makeSubscriptionToPackage(userName: string, packageName: string): Observable<Subscription>;
}

export interface ReportingDataGeneratorService {
  get(options: StartOptions): Observable<any>;
}

export interface RealTimeService {
  getData(topic: Topic): Observable<RealtimeData[]>;

  getStatusConnection(): Observable<any>;

  destroyConsumer(): Observable<any>;

  isSubscribed(): boolean;

  initConsumer(): void;

  getConsumerRegistrationInfo():  Observable<any>;
}

export interface ConverterOptions {
  mainTimeRange?: TimeRange;
  goBackTimeRange?: TimeRange;
  zoomTimeRange?: TimeRange;
  isTimeExplorerOpened?: boolean;
  colorPalette?: ColorPalette;
  globalFilters?: string[];
  currentTimeRange?: TimeRangeInterval;
  realTimeMode?: any;
  instanceColors?: InstanceColor[];
}

export interface DataConverterFactory {
  createBarConverter(widget: BarWidget, options: ConverterOptions): ChartDataConverterService;

  createBillboardConverter(widget: BillboardWidget, options: ConverterOptions): ChartDataConverterService;

  createLiquidFillGaugeConverter(widget: LiquidFillGaugeWidget, options: ConverterOptions): ChartDataConverterService;

  createLineConverter(widget: LineWidget, options: ConverterOptions): ChartDataConverterService;

  createTrendDiffConverter(widget: TrendDiffWidget, options: ConverterOptions): ChartDataConverterService;

  createTabularConverter(tabularWidget: TabularWidget, options: ConverterOptions): ChartDataConverterService;

  createSankeyConverter(widget: SankeyWidget, options: ConverterOptions): ChartDataConverterService;

  createSolidGaugeConverter(widget: SolidGaugeWidget, options: ConverterOptions): ChartDataConverterService;

  createSunburstConverter(widget: SunburstWidget, options: ConverterOptions): ChartDataConverterService;

  createGeoMapConverter(widget: GeoMapWidget, options: ConverterOptions): ChartDataConverterService;

  createCallTimeLineConverter(widget: CallTimeLineWidget, options: ConverterOptions): ChartDataConverterService;

  createBubbleConverter(widget: SunburstWidget, options: ConverterOptions): ChartDataConverterService;
}

export interface IRealTimeFactoryService {
  createRealTimeService(): RealTimeService;
}

export interface Preprocessor {
  timestampNormalizeStrategy(mainTimeRange: TimeRange, zoomTimeRange: TimeRange): ProcessStrategy;
}

export interface ISubscriptionService {
  add(subscription: WebSocketSubscription): Observable<any>;

  remove(subscription: WebSocketSubscription): Observable<string>;

  update(websocketSubscription: WebSocketSubscription): Observable<any>;

  pumpup(subscription: WebSocketSubscription): Observable<any>;
}

export interface KPIService {
  initialize(ActionPolicy: ActionPolicy[], policyInfo: PolicyInfo): Observable<any>;

  get(policyInfo: PolicyInfo): Observable<PolicyGroup>;
}
